#
# Generate a +VERSIONING script used by FILES and INSTALL to perform common
# operations on version control software used to store, retrieve and merge
# package configuration files during installations and upgrades. 
#
case "${STAGE},$1" in
UNPACK,|UNPACK,+VERSIONING)
	${CAT} > ./+VERSIONING << 'EOF'
#!@SH@
#
# +VERSIONING - interact with version control systems
#
# Usage: ./+VERSIONING REGISTER|CHECKOUT|CHECKOUT-FIRST [examplefile]
#	 ./+VERSIONING MERGE [examplefile] [firstrevision]
#	 ./+VERSIONING COMMIT
#
AWK="@AWK@"
CAT="@CAT@"
CHMOD="@CHMOD@"
CHOWN="@CHOWN@"
ECHO="@ECHO@"
GREP="@GREP@"
LS="@LS@"
MKDIR="@MKDIR@"
MV="@MV@"
PWD_CMD="@PWD_CMD@"
RM="@RM@"
RMDIR="@RMDIR@"
SED="@SED@"
SORT="@SORT@"
TEST="@TEST@"
TRUE="@TRUE@"
RCS="@RCS@"
CI="@CI@"
CO="@CO@"
MERGE="@MERGE@"

SELF=$0
ACTION=$1
CFILE=$2
FIRSTFILE=$3
exitcode=0
#VCSDIR: user set environment variable, the working directory under which a local repository may also be kept
_VCSDIR="${VCSDIR:-@VARBASE@/confrepo}"
#VCS: the versioning system to be used. Defaults to rcs, other solutions are searched in $PATH
_VCS="${VCS:-rcs}"
#REMOTEVCS: set the URI to the remote repository, leave unset or set to no in order to use a local repository 
#the URI, while required for pull/configuration deployment mode, does not enable it. by default the remote is only used to store the system configuration 
_REMOTE="${REMOTEVCS:-no}"

cd "$_VCSDIR"
if ${TEST} "$_REMOTE" = "no"; then
	#check if a local repository exists in the VCSDIR, otherwire initialize it as needed
	case $_VCS in
	"cvs")
		cvs -d "$_VCSDIR/CVSROOT" status foo 1>/dev/null
		repostatus=$?
		if ${TEST} ! $repostatus -eq 0; then
			cvs -d "$_VCSDIR/CVSROOT" init
			for module in "automerged" "defaults" "user"
				do
					if ${TEST} -d "$_VCSDIR/$module" -a -r "$_VCSDIR/$module"; then
						cd "$_VCSDIR/$module"
						cvs -d "$_VCSDIR/CVSROOT" import -m "auto import preexisting $module files" "$module" auto start					
					fi
				done
		fi
		cd "$_VCSDIR"
		for module in "automerged" "defaults" "user"
			do
				cvs -d "$_VCSDIR/CVSROOT" checkout "$module"
			done	
		;;
	*)
		;;
	esac
fi

case $ACTION in
REGISTER)
	case $_VCS in
	"rcs")
		${CI} -u "$CFILE"
		exitcode=$?
		;;
	"cvs")
		cd "$_VCSDIR"
		cvs -d "$_VCSDIR/CVSROOT" add "$CFILE"
		;;
	*)
		${ECHO} "$_CVS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
COMMIT)
	case $_VCS in
	"cvs")
		cvs -d "$_VCSDIR/CVSROOT" commit -m "pkgsrc"
		;;
	*)
		;;
	esac
	;;
CHECKOUT)
	case $_VCS in
	"rcs")
		${CO} -f "$CFILE"
		exitcode=$?
		;;
	"cvs")
		cvs -d "$_VCSDIR/CVSROOT" co "$CFILE"
		;;
	*)
		${ECHO} "$_CVS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
#checkout the initial revision of the file, used in the 3-way merge
CHECKOUT-FIRST)
	case $_VCS in
	"rcs")
		${CO} -r1 -f "$CFILE"
		exitcode=$?
		;;
	"cvs")
		cvs -d "$_VCSDIR/CVSROOT" co -r1 "$CFILE"
		;;
	*)
		${ECHO} "$_CVS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
MERGE)
	${MERGE} "$CFILE.automerge" "$FIRSTFILE" "$CFILE"
	exitcode=$?
	;;
PULL)
	${ECHO} "not yet implemented, to be called from +install"
	;;
*)
	${ECHO} "Usage: ./+VERSIONING REGISTER|CHECKOUT|CHECKOUT-FIRST [examplefile]"
	${ECHO} "Usage: ./+VERSIONING MERGE [examplefile] [firstrevision]"
	${ECHO} "Usage: ./+VERSIONING COMMIT"
	exitcode=3
	;;
esac
exit $exitcode

EOF
	${SED} -n "/^\# VERSIONING: /p" ${SELF} >> ./+VERSIONING
	${CHMOD} +x ./+VERSIONING
	;;
esac
