#
# Generate a +VERSIONING script used by FILES and INSTALL to perform common
# operations on version control software used to store, retrieve and merge
# package configuration files during installation and upgrade operations. 
#
case "${STAGE},$1" in
UNPACK,|UNPACK,+VERSIONING)
	${CAT} > ./+VERSIONING << 'EOF'
#!@SH@
#
# +VERSIONING - operate on version control systems
# set VCS_CONF_FILES=yes in order to enable configuration file version tracking!
#
# This script calls VCS software, "rcs" by default, in order to store revisions
# of configuration files. This is done by the "REGISTER" action, which takes 
# the path to an example configuration file as argument.
# Said file should be placed in the VCS working directory by the "files" script
# VERSIONING only handles the storage of revisions inside a vcs.
# Once all configuration files for a package are registered, files should call
# the COMMIT action, which will commit changes on backends that support
# atomic transactions (if using rcs, commit won't execute further operations).
# MERGE calls RCS merge to attempt a 3-way merge between the copy of an  
# installed configuration file, its original revision and the last example file
# as provided by the package. This is a non-interactive merge, if successful
# "files" will install the output in place of the existing configuration.
# CHECKOUT and CHECKOUT-FIRST exist to assist "files" in retrieving revisions
# before attempting an automatic merge.  
# Files only attempts to automatically merge changes if the environment
# variable VCSAUTOMERGE is set to "yes". A backup of the installed configuration
# is taken first, and user modified configuration files are stored separately,
# in order to enable for a quick restoration of the last known working file.
# PREPARE is called before registering files: under some VCSs it checks
# that the working directory and/or the remote repository is correctly
# initialized, and initializes it otherwise. 
# The VCSDIR environment variable is read to set the working directory,
# under which the repository will also reside, if a local vcs is being used.
# It defaults to VARBASE/confrepo.
# The VCS backend to use can be set via VCS environment variable, and defaults
# to RCS (Revision Control System).
# REMOTEVCS, if set, must contain a string that the chosen VCS understands as
# an URI to a remote repository, including login credentials if not specified
# through other means. This is non standard across different backends, and
# additional environment variables and cryptographic material 
# may need to be provided. 
# PULL tries to deploy configuration from a remote repository. It needs
# REMOTEVCS to be set, and gets called from +INSTALL if VCSCONFPULL=yes
#
# The remote configuration repository should contain branches named
# according to the following convention:
# category_pkgName_pkgVersion_compatRangeStart_compatRangeEnd_systemRole
# an optional field may exist that explicitates part of the system hostname
# category_pkgName_pkgVersion_compatRangeStart_compatRangeEnd_systemRole_hostname
#
# the branch should contain needed configuration files. Their path relative
# to the repository is then prepended with a "/" and files force copied
# to the system and chmod 0600 executed on them.
# Permission handling and removal upon package uninstallation are not supported.
#
# The branch to be used, among the available ones, is chosen this way:
# branches named according to the convention that provide configuration
# for category/packageName are filtered from the VCS output
# then, all branches whose ranges are compatible with the version of the
# package being installed are selected. The upper bound of the range is
# excluded if using sequence based identifiers.
# If system role is set through the ROLE environment variable, 
# and it's different from "any",
# and branches exists whose role is different from "any", then their
# role gets compared with the one defined on the system or in pkg_add config.
# The last part of the branch name is optional and, if present, is compared
# character by character with the system hostname, 
# finally selecting the branches that best match it.
# As an example, a branch named mail_postfix_3.3.0_3.0.0_3.3.20_mailrelay_ams
# will match with system hostname amsterdam09.
# The checks now further refine the candidates: if a branch pkgVersion exactly
# corresponds with the version of the package being installed,
# that branch gets selected, otherwise the procedure uses the one
# which is closest to the package version being installed.
# non numerical values in package versions are accounted for
# when checking for an exact match, and are otherwise ignored.
# Only integer versions and dot-separated sequence based identifiers are
# understood when checking for compatible software ranges and for the closest
# branch, if no branch exactly matches with the package version being installed.
# Dates are handled provided they follow the ISO 8601 scheme: YYYY-MM-DD, YYYYMMDD 
#
# Usage: ./+VERSIONING REGISTER|CHECKOUT|CHECKOUT-FIRST [examplefile]
#	 ./+VERSIONING MERGE [examplefile] [firstrevision]
#	 ./+VERSIONING COMMIT [message]
#	 ./+VERSIONING PRAPARE
#	 ./+VERSIONING PULL
#
AWK="@AWK@"
CAT="@CAT@"
CHMOD="@CHMOD@"
CHOWN="@CHOWN@"
ECHO="@ECHO@"
FIND="@FIND@"
GREP="@GREP@"
LS="@LS@"
MKDIR="@MKDIR@"
MV="@MV@"
PWD_CMD="@PWD_CMD@"
RM="@RM@"
RMDIR="@RMDIR@"
SED="@SED@"
SORT="@SORT@"
TAIL="@TAIL@"
TEST="@TEST@"
TR="@TR@"
TRUE="@TRUE@"
RCS="@RCS@"
CI="@CI@"
CO="@CO@"
CP="@CP@"
CUT="@CUT@"
MERGE="@MERGE@"
WC="@WC@"

SELF=$0
ACTION=$1
CFILE=$2
FIRSTFILE=$3
exitcode=0

#VCSDIR: user set environment variable, the working directory under which a local repository may also be kept
_VCSDIR="${VCSDIR:-@VARBASE@/confrepo}"
#VCS: the versioning system to be used. Defaults to rcs, other solutions are searched in $PATH
_VCS="${VCS:-rcs}"
#REMOTEVCS: set the URI to the remote repository, leave unset or set to no in order to use a local repository 
#the URI, while required for pull/configuration deployment mode, does not enable it. by default the remote is only used to store the system configuration 
_REMOTE="${REMOTEVCS:-no}"
if ${TEST} "$_VCS" = "cvs" -o "$_VCS" = "CVS"; then
	if ${TEST} "$_REMOTE" != "no"; then
		_CVSROOT="$_REMOTE"
	else
		_CVSROOT="$_VCSDIR/CVSROOT"
	fi
fi
#ROLE: the system role, used in configuration deploy mode. Defaults to any if unset
_ROLE="${ROLE:-any}"

case $ACTION in
PREPARE)
		cd "$_VCSDIR"
		case $_VCS in
		"cvs"|"CVS")
			cvs -d "$_CVSROOT" status defaults 1>/dev/null
			repostatus=$?
			if ${TEST} ! $repostatus -eq 0; then
				if ${TEST} "$_REMOTE" = "no"; then	
					cvs -d "$_CVSROOT" init
					exitcode=$?
				fi
				for module in "automerged" "defaults" "user"
					do
						if ${TEST} -d "$_VCSDIR/$module" -a -r "$_VCSDIR/$module"; then
							cd "$_VCSDIR/$module"
							cvs -d "$_CVSROOT" import -m "auto import preexisting $module files" "$module" auto start 1>/dev/null
						fi
					
					done
				cd "$_VCSDIR"
				for module in "automerged" "defaults" "user"
					do
						cvs -d "$_CVSROOT" checkout -R "$module"
					done	
			fi
			cd "$_VCSDIR"
			for module in "automerged" "defaults" "user"
				do
					cvs -d "$_CVSROOT" update -A -R "$module"
				done
			;;
		"svn"|"SVN")
			svn info "$_VCSDIR/defaults" > /dev/null
			if ${TEST} ! $? -eq 0; then
				if ${TEST} "$_REMOTE" = "no"; then
					${RM} -fr "$_VCSDIR/localsvn" 2>/dev/null
					svnadmin create "$_VCSDIR/localsvn"
					for subdir in "automerged" "defaults" "user"
						do
							svn mkdir file://"$_VCSDIR/localsvn/$subdir" -m "create $subdir conf dir"
							svn co file://"$_VCSDIR/localsvn/$subdir" "$_VCSDIR/$subdir"
						done
				else
					#manually migrate to a remote repository, if needed
					for subdir in "automerged" "defaults" "user"
						do
							if ${TEST} -d "$_VCSDIR/$subdir"; then
								svn import -m "initial import" "$_VCSDIR/$subdir" "$_REMOTE/$subdir"
							else
								svn mkdir "$_REMOTE/$subdir"
							fi
							svn co "$_REMOTE/$subdir" "$_VCSDIR/$subdir"
						done
				fi
			fi	
				svn info "$_VCSDIR/defaults" > /dev/null
				exitcode=$?
				svn update "$_VCSDIR/defaults" "$_VCSDIR/user" "$_VCSDIR/automerged" > /dev/null
			;;
		"git"|"GIT")
			git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" status > /dev/null
			gitstatus=$?
			#this script won't clone a remote repository if a local git repo already exists in the VCSDIR.
			#just setting $REMOTE won't suffice, manually move over data and clone the repo first or use git remote add
			if ${TEST} ! $gitstatus -eq 0; then 
				git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" init
				exitcode=$?
				if ${TEST} "$_REMOTE" != "no" && ${TEST} $exitcode -eq 0; then
					git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" remote add origin "$_REMOTE"
					exitcode=$?
				fi
			else
				if ${TEST} ! "$_REMOTE" = "no"; then
					if git remote | ${GREP} -Fq "origin"; then
						git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" remote remove origin
						git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" remote add origin "$_REMOTE"
						#populate the remote repo if empty
						#prefer losing remote status over local status
						git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" push origin master
						exitcode=$?
				 	else	
						git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" remote add origin "$_REMOTE"
						exitcode=$?
					fi
				fi
				 
			fi
			if ${TEST} $exitcode -eq 0 -a ! "$_REMOTE" = "no"; then
				git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" pull origin master
			fi 
			;;
		"hg"|"HG"|"mercurial")
			hg --repository "$_VCSDIR" summary > /dev/null
			if ${TEST} ! $? -eq 0; then
				hg init "$_VCSDIR"
				exitcode=$?
				if ${TEST} "$_REMOTE" != "no"; then
					hg --repository "$_VCSDIR" pull "$_REMOTE" 
					hg update -C -R "$_VCSDIR" 
					hg --repository "$_VCSDIR" summary > /dev/null
					exitcode=$?
				fi
			else
				if ${TEST} ! "$_REMOTE" = "no"; then
					hg clone . "$_REMOTE"
					hg --repository "$_VCSDIR" push "$_REMOTE"
					hg --repository "$_VCSDIR" pull "$_REMOTE"
				fi
			fi
			;;	
		"rcs"|"RCS")
			;;
		*)
			${ECHO} "$_VCS: unsupported versioning system"
			exitcode=2
			;;
		esac
	;;
REGISTER)
	case $_VCS in
	"rcs"|"RCS")
		${RCS} -U "$CFILE" > /dev/null
		${CI} -u "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $2}')
		cd $(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $1}')
		IFS="/"
		for curdir in $_PATHSPLIT
			do
				cvs -d "$_CVSROOT" add "$curdir"; cd "$curdir" 2>/dev/null
			done
		;;
	"git"|"GIT")
		cd "$_VCSDIR"
		git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" add -f "$CFILE"
		;;
	"hg"|"HG"|"mercurial")
		cd "$_VCSDIR"
		hg --repository "$_VCSDIR" add "$CFILE"
		;;
	"svn"|"SVN")
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $2}')
		cd $(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $1}')
		IFS="/"
		for curdir in $_PATHSPLIT
		do
			svn add --force --depth=empty "$curdir"; cd "$curdir" 2>/dev/null
		done
		;;
	*)
		${ECHO} "$_VCS: unsupported versioning system. I shouldn't be there!"
		exitcode=2
		;;
	esac
	;;
COMMIT)
	cd "$_VCSDIR"
	case $_VCS in
	"cvs"|"CVS")
		cvs -Q -d "$_CVSROOT" commit -R -m "pkgsrc: $2" 
		if ${TEST} $? -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi	
		;;
	"git"|"GIT")
		git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" commit -m "pkgsrc: $2"
		gitcommitstatus=$?
		if ${TEST} $gitcommitstatus -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi
		if ${TEST} "$_REMOTE" != "no"; then
			git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" push origin master
			#even if it fails, a local copy exists
			if ${TEST} ! $? -eq 0; then
				${ECHO} "git: failed to push changes to the remote repository $_REMOTE"
			fi
		fi
		;;
	"hg"|"HG"|"mercurial")
		hg --repository "$_VCSDIR" commit -m "pkgsrc: $2" --user pkgsrc > /dev/null
		hgcommitstatus=$?
		if ${TEST} $hgcommitstatus -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi
		if ${TEST} "$_REMOTE" != "no"; then
			hg --repository "$_VCSDIR" push "$_REMOTE"
			if ${TEST} ! $? -eq 0; then
				${ECHO} "hg: failed to push changes to the remote repository $_REMOTE"
			fi
		fi
		;;
	"svn"|"SVN")
		_svnexitstatus=0
		for dir in "defaults" "user" "automerged"
			do
				cd "$_VCSDIR/$dir"
				svn commit -m "pkgsrc: $2" 2>/dev/null
				if ${TEST} ! $? -eq 0; then
					_svnexitstatus=1
				fi
			done
		if ${TEST} $_svnexitstatus -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi
		;;
	*)
		;;
	esac
	;;
CHECKOUT)
	case $_VCS in
	"rcs"|"RCS")
		${CO} -f "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}' | ${SED} 's@//@/@' | ${SED} 's@/@@')
		cvs -d "$_CVSROOT" co "$_PATHSPLIT"
		;;
	"git"|"GIT")
		cd "$_VCSDIR"
		git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" checkout -- "$CFILE"
		;;
	"svn"|"SVN")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}')
		if ${TEST} "$_REMOTE" = "no"; then
			svn export --force file://"$_VCSDIR/localsvn/$_PATHSPLIT" "$CFILE"
		else
			svn export --force "$_REMOTE/$_PATHSPLIT" "$CFILE"
		fi
		;;
	"hg"|"HG"|"mercurial")
		cd "$_VCSDIR"
		hg --repository "$_VCSDIR" cat -r tip "$CFILE" > "$CFILE"
		;;
	*)
		${ECHO} "$_VCS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
#checkout the initial revision of the file, used in the 3-way merge
CHECKOUT-FIRST)
	case $_VCS in
	"rcs"|"RCS")
		${CO} -f1.1 "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}' | ${SED} 's@//@/@' | ${SED} 's@/@@')
		cvs -d "$_CVSROOT" co -r1.1 "$_PATHSPLIT"
		;;
	"git"|"GIT")
		cd "$_VCSDIR"
		git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" checkout $(git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" rev-list HEAD "$CFILE" | ${TAIL} -n 1) -- "$CFILE"
		;;
	"hg"|"HG"|"mercurial")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}' | ${CUT} -c 2-)
		hg --repository "$_VCSDIR" cat -r "first(file("$_PATHSPLIT"),1)" "$CFILE" > "$CFILE"
		;;
	"svn"|"SVN")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}')
		if ${TEST} "$_REMOTE" = "no"; then
			svn export --force --revision $(svn log --xml -r 1:HEAD --limit 1 file://"$_VCSDIR/localsvn/$_PATHSPLIT" | ${AWK} -F '"' '/revision=/ {print $2}') file://"$_VCSDIR/localsvn/$_PATHSPLIT" "$CFILE"
		else
			svn export --force --revision $(svn log --xml -r 1:HEAD --limit 1 "$_REMOTE/$_PATHSPLIT" | ${AWK} -F '"' '/revision=/ {print $2}') "$_REMOTE/$_PATHSPLIT" "$CFILE"
		fi
		;;
	*)
		${ECHO} "$_VCS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
MERGE)
	${MERGE} "$FIRSTFILE.automerge" "$FIRSTFILE" "$CFILE"
	exitcode=$?
	;;
PULL)
	#change in spec: branch name contains package name
	#category_baseName_pkgVersion_rangeStart_rangeEnd_systemRole_optionalHostname
	#remember to set the env variables $ROLE and $HOSTNAME
	${ECHO} "Trying to deploy configuration from $_REMOTE via $_VCS"
	exitcode=0
	branchFound=no
	compatibleBranches=""
	branchName=""
	#can a package have multiple categories defined?
	category=$2
	name=$3
	exactVersion=$4
	shortVersion=$(${ECHO} $5 | ${AWK} -F "$name" '{print $2}' | ${TR} -dc '[0-9].')
	branchesOutput=""
	_TEMPDIR="/tmp/pkgsrcdeploy-$RANDOM"
	while ${TEST} -d $_TEMPDIR; do
		#this should never happen!
		${RM} -fr "$_TEMPDIR"
		_TEMPDIR="/tmp/pkgsrcdeploy-$RANDOM"
	done
	${MKDIR} -p "$_TEMPDIR"
	${CHMOD} 0700 "$_TEMPDIR"
	cd "$_TEMPDIR"
	case "$_VCS" in
		"git"|"GIT")
			_output=$(git ls-remote --refs "$_REMOTE" "$category"_"$name""_*")
			exitcode=$?
			_output=$(${ECHO} "$_output" | ${AWK} -F "refs/heads/" '{print $2}')
			;;
		"svn"|"SVN")
			if ! ${ECHO} "$_REMOTE" | ${GREP} -Fq "/branches"; then
				_REMOTE="$_REMOTE/branches/"
			fi
			_output=$(svn ls "$_REMOTE")
			exitcode=$?
			_output=$(${ECHO} "$_output" | ${SED} 's@/@@g' | ${GREP} "$category_$name_")
			#it would be more accurate to iterate over single branch names, split them and check for category_name
			;;
		#Mercurial, CVS require to checkout the remote repository locally before listing branches...
		"hg"|"HG"|"mercurial")
			hg clone "$_REMOTE" "$_TEMPDIR/work"
			exitcode=$?
			if ${TEST} $exitcode -eq 0; then
				_output=$(hg branches -R "$_TEMPDIR/work" | ${AWK} -v search="$category_$name_" '$0 ~search {print $1}')
				exitcode=$?
			fi	
			;;
		"rcs"|"RCS"|*)
			${ECHO} "configuration deploy: $_VCS is not supported"
			if ${TEST} -z "$VCS"; then
				${ECHO} "set VCS to use configuration deploy in pkgsrc! Supported solutions are git, svn and hg"
			fi
			exitcode=2
			;;
	esac
	if ${TEST} $exitcode -eq 0 -a -n "$_output"; then 
		#sanitize the output first
		for branch in $_output
			do
				if ${TEST} $(${ECHO} "$branch" | ${GREP} -o "_" | ${WC} -l) -gt 4 && \
					${TEST} "$(${ECHO} "$branch" | ${AWK} -F "_" '{print $1}')" = "$category" && \
					${TEST} "$(${ECHO} "$branch" | ${AWK} -F "_" '{print $2}')" = "$name" && \
					${TEST} -n "$(${ECHO} "$branch" | ${AWK} -F "_" '{print $3}' | ${TR} -dc '[0-9]')" && \
					${TEST} -n "$(${ECHO} "$branch" | ${AWK} -F "_" '{print $4}' | ${TR} -dc '[0-9]')" && \
					${TEST} -n "$(${ECHO} "$branch" | ${AWK} -F "_" '{print $5}' | ${TR} -dc '[0-9]')"; then
						compatibleBranches="$branch $compatibleBranches"
				else
					${ECHO} "Warning: ignoring branch with invalid naming: $branch"
					${ECHO} "category_packageName_packageVersion_compatRangeStart_compatRangeEnd_systemRole_optionalHostname"
				fi
			done
		_output=$compatibleBranches
		compatibleBranches=""
		for branch in $_output
			do
				_rangeStart=$(${ECHO} "$branch" | ${AWK} -F "_" '{print $4}')
				_rangeEnd=$(${ECHO} "$branch" | ${AWK} -F "_" '{print $5}')
				_branchRole=$(${ECHO} "$branch" | ${AWK} -F "_" '{print $6}')
				if ${ECHO} "$branch" | ${GREP} -Fq '.'; then
					if ! ${ECHO} "$shortVersion" | ${GREP} -Fq '.'; then
						${ECHO} "$branch: branch naming incompatible with package version naming!"
						continue
					fi
					#compare versions
					_rangeStartLTshortVersion=true
					_rangeEndGTshortVersion=false
					_groupCounter=1
					for intGroup in $(${ECHO} "$shortVersion" | ${SED} 's/\./ /g')
						do
							_rangeStartGroup=$(${ECHO} "$_rangeStart" | ${AWK} -F "." -v sep="$_groupCounter" '{print $sep}')
							_rangeEndGroup=$(${ECHO} "$_rangeEnd" | ${AWK} -F "." -v sep="$_groupCounter" '{print $sep}')
							if ${TEST} -n "$_rangeStartGroup" && ${TEST} $_rangeStartGroup -gt $intGroup; then
								_rangeStartLTshortVersion=false
								break
							fi
							if ${TEST} -n "$_rangeEndGroup" && ${TEST} ! "$_rangeEndGTshortVersion" = "true" && ${TEST} $_rangeEndGroup -gt $intGroup; then
								_rangeEndGTshortVersion=true
							else
								break
							fi
							_groupCounter=$((_groupCounter + 1))
						done
					if ${TEST} "$_rangeStartLTshortVersion" = "true" -a "$_rangeEndGTshortVersion" = "true"; then
						if ${TEST} "$_branchRole" = "any" -o "$_branchRole" = "ANY" -o "$_branchRole" = "$_ROLE" -o "$_ROLE" = "any"; then 
							compatibleBranches="$branch $compatibleBranches"
						fi
					fi
				else
					if ${ECHO} "$shortVersion" | ${GREP} -Fq '.'; then
						${ECHO} "$branch: branch naming incompatible with package version naming!"
						continue
					fi
					#numerically compare versions
					if ${TEST} "$_rangeStart" -lt "$shortVersion" -o "$_rangeStart" -eq "$shortVersion" && ${TEST} "$_rangeEnd" -gt "$shortVersion" -o "$_rangeEnd" -eq "$shortVersion"; then
						if ${TEST} "$_branchRole" = "any" -o "$_branchRole" = "ANY" -o "$_branchRole" = "$_ROLE" -o "$_ROLE" = "any"; then
							compatibleBranches="$compatibleBranches $branch"
						fi
					fi
				fi
			done
		if ${TEST} -z "$compatibleBranches"; then
			${ECHO} "Error: no compatible branches found for $category/$name-$shortVersion! Using package defaults"
			${RM} -fr "$_TEMPDIR"
			exit 6
		fi
		#check for hostnames, best effort
		if ${TEST} -n "$HOSTNAME" -a ! "$HOSTNAME" = "localhost"; then
			bestHostnameMatchChars=1
			bestHostnameMatch=""
			compatibleHostnames=""
			_charCounter=1
			for branch in $compatibleBranches
				do
					if ${TEST} $(${ECHO} "$branch" | ${GREP} -o "_" | ${WC} -l) -gt 5; then
						#optional hostname exists in branch name
						_branchHostname=$(${ECHO} "$branch" | ${AWK} -F "_" '{$1=$2=$3=$4=$5=$6=""; print $0}')
						_charCounter=1
						for character in $(${ECHO} "$_branchHostname" | ${GREP} -o ".") 
							do
								if ${TEST} ! "$character" = $(${ECHO} "$HOSTNAME" | ${CUT} -c $_charCounter); then
									break
								else
									_charCounter=$((_charCounter+1))
								fi
							done
					fi
					if ${TEST} $_charCounter -gt $bestHostnameMatchChars; then
						bestHostnameMatchChars=$_charCounter
						bestHostnameMatch=$_branchHostname
					fi
				done
			compatibleBranchesWithHostnames=""
			if ${TEST} -n "$bestHostnameMatch"; then
				for branch in $compatibleBranches
					do
						if ${TEST} $(${ECHO} "$branch" | ${GREP} -o "_" | ${WC} -l) -eq 6 && ${TEST} $(${ECHO} "$branch" | ${AWK} -F "_" '{print $7}') = "$bestHostnameMatch"; then
							compatibleBranchesWithHostnames="$branch $compatibleBranchesWithHostnames"
						fi
					done
				compatibleBranches=$compatibleBranchesWithHostnames
				if ${TEST} $(${ECHO} "$compatibleBranches" | ${GREP} -o "$bestHostnameMatch" | ${WC} -l) -eq 1; then
					branchFound=yes
					branchName=$compatibleBranches
				fi
					
			fi
		fi
		if ${TEST} ! "$branchFound" = "yes"; then
			#then check for an exact match! first with exactVersion, else with shortVersion
			for branch in $compatibleBranches
				do
					
					if ${TEST} "$(${ECHO} "$branch" | ${AWK} -F "_" '{print $3}')" = "$exactVersion"; then
						branchFound=yes
						branchName=$branch
						break	
					elif ${TEST} "$(${ECHO} "$branch" | ${AWK} -F "_" '{print $3}')" = "$shortVersion"; then
						branchFound=yes
						branchName=$branch
						break
					fi
				done
			#if the branch is still not found, select the best compatible branch in range.
			branch=$(${ECHO} "$compatibleBranches" | ${AWK} -F " " '{print $1}')
			branchVersion=$(${ECHO} "$branch" | ${AWK} -F "_" '{print $3}'| ${TR} -dc '[0-9].') 
			if ! ${ECHO} "$shortVersion" | ${GREP} -Fq '.'; then
				#compare integers
				versionDistance=$(($shortVersion - $branchVersion))
				versionDistance=${versionDistance#-}
				minimumDistance=$versionDistance
				bestBranch=$branch
				for branch in $compatibleBranches
					do
						branchVersion=$(${ECHO} "$branch" | ${AWK} -F "_" '{print $3}' | ${TR} -dc '[0-9].')
						versionDistance=$(($shortVersion - $branchVersion))
						versionDistance=${versionDistance#-}
						if ${TEST} $versionDistance -lt $minimumDistance; then
							minimumDistance=$versionDistance
							bestBranch=$branch
						fi
							
					done
				branchFound=yes
				branchName=$bestBranch
			else
				#dots in version numbers!
				bestBranch=$branch
				_branches=$compatibleBranches
				groupCounter=1
				for intGroup in $(${ECHO} "$shortVersion" | ${AWK} -F "." '{print $0}')
					do
						bestBranchGroup="$_branches"
						minimumDistance=$(( $(${ECHO} "$shortVersion" | ${AWK} -F "." -v sep="$groupCounter" '{print $sep}') - $(${ECHO} "$_branches" | ${AWK} -F " " '{print $1}' | ${AWK} -F "_" '{print $3}' | ${TR} -dc '[0-9].' | ${AWK} -F "." -v sep="$groupCounter" '{print $sep}') ))
						miniumDistance=${minimumDistance#-}
						branchCounter=1
						for branch in $_branches
							do
								groupDistance=$(( $(${ECHO} "$shortVersion" | ${AWK} -F "." -v sep="$groupCounter" '{print $sep}') - $(${ECHO} "$_branches" | ${AWK} -F " " -v sep="$branchCounter" '{print $sep}' | ${AWK} -F "_" '{print $3}' | ${TR} -dc '[0-9].' | ${AWK} -F "." -v sep="$groupCounter" '{print $sep}') ))
								groupDistance=${groupDistance#-}
								if ${TEST} $groupDistance -lt $minimumDistance; then
									minimumDistance=$groupDistance
									bestBranchGroup=$branch	
								elif ${TEST} $groupDistance -eq $minimumDistance; then
									bestBranchGroup="$bestBranchGroup $branch"
								fi
								branchCounter=$((branchCounter + 1))
							done
						_branches=$bestBranchGroup
						groupCounter=$((groupCounter + 1))
					done
					if ${TEST} -n "$_branches"; then
					#I should always have one and only one branch in _branches at the end...
						bestBranch=$(${ECHO} "$_branches" | ${AWK} -F " " '{print $1}')
						branchFound=yes
					fi
				branchName=$bestBranch	
			fi		
		fi
	fi
	if ${TEST} $branchFound = "yes" -a $exitcode -eq 0; then
		branchName=$(${ECHO} $branchName | ${SED} 's/ //g')
		${ECHO} "about to use remote branch $branchName"
		case "$_VCS" in
			"git"|"GIT")
				git --git-dir="$_TEMPDIR/.git" --work-tree="$_TEMPDIR/work" clone -b "$branchName" "$_REMOTE"
				exitcode=$? 
				;;
			"svn"|"SVN")
				svn co "$_REMOTE/$branchName" "$_TEMPDIR/work"
				exitcode=$?
				if ${TEST} $exitcode -eq 0; then
					${RM} -fr "$_TEMPDIR/work/.svn"
					exitcode=$?
				fi
				;;
			"hg"|"HG"|"mercurial")
					hg -R "$_TEMPDIR/work" update -C "$branchName"
					exitcode=$?
					if ${TEST} $exitcode -eq 0; then
						${RM} -fr "$_TEMPDIR/work/.hg"
						exitcode=$?
					fi
				;;
		esac
		if ${TEST} $exitcode -eq 0; then
			${FIND} "$_TEMPDIR/work" -type f -print | while read line; do relativePath=$(${ECHO} "$line" | ${AWK} -F "$_TEMPDIR/work" '{print $2}'); ${MKDIR} -p "$relativePath" 2>/dev/null; ${RMDIR} "$relativePath" 2>/dev/null; ${CP} -v -f "$line" "$relativePath"; cpexitcode=$?; ${CHMOD} 0600 "$relativePath"; if ${TEST} ! $cpexitcode -eq 0; then exitcode=5; fi; done  
		fi
	fi
	${RM} -fr "$_TEMPDIR"
	if ${TEST} ! $exitcode -eq 0; then
		${ECHO} "Error deploying configuration for $category/$name: using package defaults"
	fi
	;;
*)
	${ECHO} "Usage: ./+VERSIONING REGISTER|CHECKOUT|CHECKOUT-FIRST [examplefile]"
	${ECHO} "Usage: ./+VERSIONING MERGE [examplefile] [firstrevision]"
	${ECHO} "Usage: ./+VERSIONING COMMIT [message]"
	${ECHO} "Usage: ./+VERSIONING PREPARE"
	${ECHO} "Usage: ./+VERSIONING PULL"
	exitcode=3
	;;
esac
exit $exitcode

EOF
	${SED} -n "/^\# VERSIONING: /p" ${SELF} >> ./+VERSIONING
	${CHMOD} +x ./+VERSIONING
	;;
esac
