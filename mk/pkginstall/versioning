#
# Generate a +VERSIONING script used by FILES and INSTALL to perform common
# operations on version control software used to store, retrieve and merge
# package configuration files during installation and upgrade operations. 
#
case "${STAGE},$1" in
UNPACK,|UNPACK,+VERSIONING)
	${CAT} > ./+VERSIONING << 'EOF'
#!@SH@
#
# +VERSIONING - operate on version control systems
#
# This script calls VCS software, "rcs" by default, in order to store revisions
# of configuration files. This is done by the "REGISTER" action, which takes 
# the path to an example configuration file as argument.
# Said file should be placed in the VCS working directory by the "files" script
# VERSIONING only handles the storage of revisions inside a vcs.
# Once all configuration files for a package are registered, files should call
# the COMMIT action, which will commit changes on backends that support
# atomic transactions (if using rcs, commit won't execute further operations).
# MERGE calls RCS merge to attempt a 3-way merge between the copy of an  
# installed configuration file, its original revision and the last example file
# as provided by the package. This is a non-interactive merge, if successful
# "files" will install the output in place of the existing configuration.
# CHECKOUT and CHECKOUT-FIRST exist to assist "files" in retrieving revisions
# before attempting an automatic merge.  
# Files only attempts to automatically merge changes if the environment
# variable VCSAUTOMERGE is set to "yes". A backup of the installed configuration
# is taken first, and user modified configuration files are stored separately,
# in order to enable for a quick restoration of the last known working file.
# PREPARE is called before registering files: under some VCSs it checks
# that the working directory and/or the remote repository is correctly
# initialized, and initializes it otherwise. 
# The VCSDIR environment variable is read to set the working directory,
# under which the repository will also reside, if a local vcs is being used.
# It defaults to VARBASE/confrepo.
# The VCS backend to use can be set via VCS environment variable, and defaults
# to RCS (Revision Control System).
# REMOTEVCS, if set, must contain a string that the chosen VCS understands as
# an URI to a remote repository, including login credentials if not specified
# through other means. This is non standard across different backends, and
# additional environment variables and cryptographic material 
# may need to be provided. 
#
# Usage: ./+VERSIONING REGISTER|CHECKOUT|CHECKOUT-FIRST [examplefile]
#	 ./+VERSIONING MERGE [examplefile] [firstrevision]
#	 ./+VERSIONING COMMIT [message]
#	 ./+VERSIONING PRAPARE
#
AWK="@AWK@"
CAT="@CAT@"
CHMOD="@CHMOD@"
CHOWN="@CHOWN@"
ECHO="@ECHO@"
GREP="@GREP@"
LS="@LS@"
MKDIR="@MKDIR@"
MV="@MV@"
PWD_CMD="@PWD_CMD@"
RM="@RM@"
RMDIR="@RMDIR@"
SED="@SED@"
SORT="@SORT@"
TAIL="@TAIL@"
TEST="@TEST@"
TRUE="@TRUE@"
RCS="@RCS@"
CI="@CI@"
CO="@CO@"
CUT="@CUT@"
MERGE="@MERGE@"

SELF=$0
ACTION=$1
CFILE=$2
FIRSTFILE=$3
exitcode=0
#VCSDIR: user set environment variable, the working directory under which a local repository may also be kept
_VCSDIR="${VCSDIR:-@VARBASE@/confrepo}"
#VCS: the versioning system to be used. Defaults to rcs, other solutions are searched in $PATH
_VCS="${VCS:-rcs}"
#REMOTEVCS: set the URI to the remote repository, leave unset or set to no in order to use a local repository 
#the URI, while required for pull/configuration deployment mode, does not enable it. by default the remote is only used to store the system configuration 
_REMOTE="${REMOTEVCS:-no}"
if ${TEST} "$_VCS" = "cvs" -o "$_VCS" = "CVS"; then
	if ${TEST} "$_REMOTE" != "no"; then
		_CVSROOT="$_REMOTE"
	else
		_CVSROOT="$_VCSDIR/CVSROOT"
	fi
fi
cd "$_VCSDIR"

case $ACTION in
PREPARE)
		case $_VCS in
		"cvs"|"CVS")
			cvs -d "$_CVSROOT" status defaults 1>/dev/null
			repostatus=$?
			if ${TEST} ! $repostatus -eq 0; then
				if ${TEST} "$_REMOTE" = "no"; then	
					cvs -d "$_CVSROOT" init
					exitcode=$?
				fi
				for module in "automerged" "defaults" "user"
					do
						if ${TEST} -d "$_VCSDIR/$module" -a -r "$_VCSDIR/$module"; then
							cd "$_VCSDIR/$module"
							cvs -d "$_CVSROOT" import -m "auto import preexisting $module files" "$module" auto start 1>/dev/null
						fi
					
					done
				cd "$_VCSDIR"
				for module in "automerged" "defaults" "user"
					do
						cvs -d "$_CVSROOT" checkout -R "$module"
					done	
			fi
			cd "$_VCSDIR"
			for module in "automerged" "defaults" "user"
				do
					cvs -d "$_CVSROOT" update -A -R "$module"
				done
			;;
		"svn"|"SVN")
			cd "$_VCSDIR"
			svn info "$_VCSDIR/defaults" > /dev/null
			if ${TEST} ! $? -eq 0; then
				if ${TEST} "$_REMOTE" = "no"; then
					${RM} -fr "$_VCSDIR/localsvn" 2>/dev/null
					svnadmin create "$_VCSDIR/localsvn"
					for subdir in "automerged" "defaults" "user"
						do
							svn mkdir file://"$_VCSDIR/localsvn/$subdir" -m "create $subdir conf dir"
							svn co file://"$_VCSDIR/localsvn/$subdir" "$_VCSDIR/$subdir"
						done
				else
					#manually migrate to a remote repository, if needed
					for subdir in "automerged" "defaults" "user"
						do
							if ${TEST} -d "$_VCSDIR/$subdir"; then
								svn import -m "initial import" "$_VCSDIR/$subdir" "$_REMOTE/$subdir"
							else
								svn mkdir "$_REMOTE/$subdir"
							fi
							svn co "$_REMOTE/$subdir" "$_VCSDIR/$subdir"
						done
				fi
			fi	
				svn info "$_VCSDIR/defaults" > /dev/null
				exitcode=$?
				svn update "$_VCSDIR/defaults" "$_VCSDIR/user" "$_VCSDIR/automerged" > /dev/null
			;;
		"git"|"GIT")
			cd "$_VCSDIR"
			git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" status > /dev/null
			gitstatus=$?
			#this script won't clone a remote repository if a local git repo already exists in the VCSDIR.
			#just setting $REMOTE won't suffice, manually move over data and clone the repo first or use git remote add
			if ${TEST} ! $gitstatus -eq 0; then 
				if ${TEST} "$_REMOTE" = "no"; then
					git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" init
					exitcode=$?
				else
					git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" clone "$_REMOTE" .
					exitcode=$?
				fi
			else
				if ${TEST} ! "$_REMOTE" = "no"; then
					if ${TEST} $(git remote | ${GREP} -c "origin") -gt 0; then
						git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" remote remove origin
						git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" remote add origin "$_REMOTE"
						#populate the remote repo if empty
						#prefer losing remote status over local status
						git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" push origin master
						exitcode=$?
				 	else	
						git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" remote add origin "$_REMOTE"
						exitcode=$?
					fi
				fi
				 
			fi
			if ${TEST} $exitcode -eq 0 -a ! "$_REMOTE" = "no"; then
				git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" pull origin master
			fi 
			;;
		"hg"|"HG"|"mercurial")
			cd "$_VCSDIR"
			hg --repository "$_VCSDIR" summary > /dev/null
			if ${TEST} ! $? -eq 0; then
				hg init "$_VCSDIR"
				exitcode=$?
				if ${TEST} "$_REMOTE" != "no"; then
					hg --repository "$_VCSDIR" pull "$_REMOTE" 
					hg update -C -R "$_VCSDIR" 
					hg --repository "$_VCSDIR" summary > /dev/null
					exitcode=$?
				fi
			else
				if ${TEST} ! "$_REMOTE" = "no"; then
					hg clone . "$_REMOTE"
					hg --repository "$_VCSDIR" push "$_REMOTE"
					hg --repository "$_VCSDIR" pull "$_REMOTE"
				fi
			fi
			;;	
		"rcs"|"RCS")
			;;
		*)
			${ECHO} "$_VCS: unsupported versioning system"
			exitcode=2
			;;
		esac
	;;
REGISTER)
	case $_VCS in
	"rcs"|"RCS")
		${RCS} -U "$CFILE" > /dev/null
		${CI} -u "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $2}')
		cd $(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $1}')
		IFS="/"
		for curdir in $_PATHSPLIT
			do
				cvs -d "$_CVSROOT" add "$curdir"; cd "$curdir" 2>/dev/null
			done
		;;
	"git"|"GIT")
		cd "$_VCSDIR"
		git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" add -f "$CFILE"
		;;
	"hg"|"HG"|"mercurial")
		cd "$_VCSDIR"
		hg --repository "$_VCSDIR" add "$CFILE"
		;;
	"svn"|"SVN")
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $2}')
		cd $(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $1}')
		IFS="/"
		for curdir in $_PATHSPLIT
		do
			svn add --force --depth=empty "$curdir"; cd "$curdir" 2>/dev/null
		done
		;;
	*)
		${ECHO} "$_VCS: unsupported versioning system. I shouldn't be there!"
		exitcode=2
		;;
	esac
	;;
COMMIT)
	case $_VCS in
	"cvs"|"CVS")
		cd "$_VCSDIR"
		cvs -Q -d "$_CVSROOT" commit -R -m "pkgsrc: $2" 
		if ${TEST} $? -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi	
		;;
	"git"|"GIT")
		cd "$_VCSDIR"
		git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" commit -m "pkgsrc: $2" > /dev/null
		gitcommitstatus=$?
		if ${TEST} $gitcommitstatus -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi
		if ${TEST} "$_REMOTE" != "no"; then
			git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" push origin master
			#even if it fails, a local copy exists
			if ${TEST} ! $? -eq 0; then
				${ECHO} "git: failed to push changes to the remote repository $_REMOTE"
			fi
		fi
		;;
	"hg"|"HG"|"mercurial")
		cd "$_VCSDIR"
		hg --repository "$_VCSDIR" commit -m "pkgsrc: $2" --user pkgsrc > /dev/null
		hgcommitstatus=$?
		if ${TEST} $hgcommitstatus -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi
		if ${TEST} "$_REMOTE" != "no"; then
			hg --repository "$_VCSDIR" push "$_REMOTE"
			if ${TEST} ! $? -eq 0; then
				${ECHO} "hg: failed to push changes to the remote repository $_REMOTE"
			fi
		fi
		;;
	"svn"|"SVN")
		cd "$_VCSDIR"
		_svnexitstatus=0
		for dir in "defaults" "user" "automerged"
			do
				cd "$_VCSDIR/$dir"
				svn commit -m "pkgsrc: $2" 2>/dev/null
				if ${TEST} ! $? -eq 0; then
					_svnexitstatus=1
				fi
			done
		if ${TEST} $_svnexitstatus -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi
		;;
	*)
		;;
	esac
	;;
CHECKOUT)
	case $_VCS in
	"rcs"|"RCS")
		${CO} -f "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}' | ${SED} 's@//@/@' | ${SED} 's@/@@')
		cvs -d "$_CVSROOT" co "$_PATHSPLIT"
		;;
	"git"|"GIT")
		cd "$_VCSDIR"
		git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" checkout -- "$CFILE"
		;;
	"svn"|"SVN")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}')
		if ${TEST} "$_REMOTE" = "no"; then
			svn export --force file://"$_VCSDIR/localsvn/$_PATHSPLIT" "$CFILE"
		else
			svn export --force "$_REMOTE/$_PATHSPLIT" "$CFILE"
		fi
		;;
	"hg"|"HG"|"mercurial")
		cd "$_VCSDIR"
		hg --repository "$_VCSDIR" cat -r tip "$CFILE" > "$CFILE"
		;;
	*)
		${ECHO} "$_VCS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
#checkout the initial revision of the file, used in the 3-way merge
CHECKOUT-FIRST)
	case $_VCS in
	"rcs"|"RCS")
		${CO} -f1.1 "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}' | ${SED} 's@//@/@' | ${SED} 's@/@@')
		cvs -d "$_CVSROOT" co -r1.1 "$_PATHSPLIT"
		;;
	"git"|"GIT")
		cd "$_VCSDIR"
		git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" checkout $(git --git-dir="$_VCSDIR/.git" --work-tree="$_VCSDIR" rev-list HEAD "$CFILE" | ${TAIL} -n 1) -- "$CFILE"
		;;
	"hg"|"HG"|"mercurial")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}' | ${CUT} -c 2-)
		hg --repository "$_VCSDIR" cat -r "first(file("$_PATHSPLIT"),1)" "$CFILE" > "$CFILE"
		;;
	"svn"|"SVN")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}')
		if ${TEST} "$_REMOTE" = "no"; then
			svn export --force --revision $(svn log --xml -r 1:HEAD --limit 1 file://"$_VCSDIR/localsvn/$_PATHSPLIT" | ${AWK} -F '"' '/revision=/ {print $2}') file://"$_VCSDIR/localsvn/$_PATHSPLIT" "$CFILE"
		else
			svn export --force --revision $(svn log --xml -r 1:HEAD --limit 1 "$_REMOTE/$_PATHSPLIT" | ${AWK} -F '"' '/revision=/ {print $2}') "$_REMOTE/$_PATHSPLIT" "$CFILE"
		fi
		;;
	*)
		${ECHO} "$_VCS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
MERGE)
	${MERGE} "$FIRSTFILE.automerge" "$FIRSTFILE" "$CFILE"
	exitcode=$?
	;;
PULL)
	${ECHO} "not yet implemented, to be called from +install"
	;;
*)
	${ECHO} "Usage: ./+VERSIONING REGISTER|CHECKOUT|CHECKOUT-FIRST [examplefile]"
	${ECHO} "Usage: ./+VERSIONING MERGE [examplefile] [firstrevision]"
	${ECHO} "Usage: ./+VERSIONING COMMIT [message]"
	${ECHO} "Usage: ./+VERSIONING PREPARE"
	exitcode=3
	;;
esac
exit $exitcode

EOF
	${SED} -n "/^\# VERSIONING: /p" ${SELF} >> ./+VERSIONING
	${CHMOD} +x ./+VERSIONING
	;;
esac
