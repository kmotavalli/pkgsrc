#
# Generate a +VERSIONING script used by FILES and INSTALL to perform common
# operations on version control software used to store, retrieve and merge
# package configuration files during installation and upgrade operations. 
#
case "${STAGE},$1" in
UNPACK,|UNPACK,+VERSIONING)
	${CAT} > ./+VERSIONING << 'EOF'
#!@SH@
#
# +VERSIONING - operate on version control systems
#
# This script calls VCS software, "rcs" by default, in order to store revisions
# of configuration files. This is done by the "REGISTER" action, which takes 
# the path to an example configuration file as argument.
# Said file should be placed in the VCS working directory by the "files" script
# VERSIONING only handles the storage of revisions inside a vcs.
# Once all configuration files for a package are registered, files should call
# the COMMIT action, which will commit changes on backends that support
# atomic transactions (if using rcs, commit won't execute further operations).
# MERGE calls RCS merge to attempt a 3-way merge between the copy of an  
# installed configuration file, its original revision and the last example file
# as provided by the package. This is a non-interactive merge, if successful
# "files" will install the output in place of the existing configuration.
# CHECKOUT and CHECKOUT-FIRST exist to assist "files" in retrieving revisions
# before attempting an automatic merge.  
# Files only attempts to automatically merge changes if the environment
# variable VCSAUTOMERGE is set to "yes". A backup of the installed configuration
# is taken first, and user modified configuration files are stored separately,
# in order to enable for a quick restoration of the last known working file.
# PREPARE is called before registering files: under some VCSs it checks
# that the working directory and/or the remote repository is correctly
# initialized, and initializes it otherwise. 
# The VCSDIR environment variable is read to set the working directory,
# under which the repository will also reside, if a local vcs is being used.
# It defaults to VARBASE/confrepo.
# The VCS backend to use can be set via VCS environment variable, and defaults
# to RCS (Revision Control System).
# REMOTEVCS, if set, must contain a string that the chosen VCS understands as
# an URI to a remote repository, including login credentials if not specified
# through other means. This is non standard across different backends, and
# additional environment variables and cryptographic material 
# may need to be provided. 
#
# Usage: ./+VERSIONING REGISTER|CHECKOUT|CHECKOUT-FIRST [examplefile]
#	 ./+VERSIONING MERGE [examplefile] [firstrevision]
#	 ./+VERSIONING COMMIT [message]
#	 ./+VERSIONING PRAPARE
#
AWK="@AWK@"
CAT="@CAT@"
CHMOD="@CHMOD@"
CHOWN="@CHOWN@"
ECHO="@ECHO@"
GREP="@GREP@"
LS="@LS@"
MKDIR="@MKDIR@"
MV="@MV@"
PWD_CMD="@PWD_CMD@"
RM="@RM@"
RMDIR="@RMDIR@"
SED="@SED@"
SORT="@SORT@"
TEST="@TEST@"
TRUE="@TRUE@"
RCS="@RCS@"
CI="@CI@"
CO="@CO@"
MERGE="@MERGE@"

SELF=$0
ACTION=$1
CFILE=$2
FIRSTFILE=$3
exitcode=0
#VCSDIR: user set environment variable, the working directory under which a local repository may also be kept
_VCSDIR="${VCSDIR:-@VARBASE@/confrepo}"
#VCS: the versioning system to be used. Defaults to rcs, other solutions are searched in $PATH
_VCS="${VCS:-rcs}"
#REMOTEVCS: set the URI to the remote repository, leave unset or set to no in order to use a local repository 
#the URI, while required for pull/configuration deployment mode, does not enable it. by default the remote is only used to store the system configuration 
_REMOTE="${REMOTEVCS:-no}"
if ${TEST} "$_VCS" = "cvs" -o "$_VCS" = "CVS"; then
	if ${TEST} "$_REMOTE" != "no"; then
		_CVSROOT="$_REMOTE"
	else
		_CVSROOT="$_VCSDIR/CVSROOT"
	fi
fi
cd "$_VCSDIR"

case $ACTION in
PREPARE)
		case $_VCS in
		"cvs"|"CVS")
			if ${TEST} "$_REMOTE" = "no"; then
				cvs -d "$_CVSROOT" status user 1>/dev/null
				repostatus=$?
				if ${TEST} ! $repostatus -eq 0; then
					cvs -d "$_CVSROOT" init
					for module in "automerged" "defaults" "user"
						do
							if ${TEST} -d "$_VCSDIR/$module" -a -r "$_VCSDIR/$module"; then
								cd "$_VCSDIR/$module"
								cvs -d "$_CVSROOT" import -m "auto import preexisting $module files" "$module" auto start 1>/dev/null					
							fi
						done
				fi
			fi
			cd "$_VCSDIR"
			for module in "automerged" "defaults" "user"
				do
					cvs -d "$_CVSROOT" checkout -R "$module"
				done
			;;
		*)
			;;
		esac
	;;
REGISTER)
	case $_VCS in
	"rcs"|"RCS")
		${RCS} -U "$CFILE"
		${CI} -u "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $2}')
		cd $(${ECHO} "$CFILE" | ${AWK} -F "//" '{print $1}')
		IFS="/"
		for curdir in $_PATHSPLIT
			do
				cvs -d "$_CVSROOT" add "$curdir"; cd "$curdir" 2>/dev/null
			done
		;;
	*)
		${ECHO} "$_CVS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
COMMIT)
	case $_VCS in
	"cvs"|"CVS")
		cd "$_VCSDIR"
		cvs -Q -d "$_CVSROOT" commit -R -m "pkgsrc: $2" 
		if ${TEST} $? -eq 0; then
			${ECHO} "conf commit: pkgsrc: $2"
		else
			${ECHO} "failed to commit conf: $2"
			exitcode=3
		fi	
		;;
	*)
		;;
	esac
	;;
CHECKOUT)
	case $_VCS in
	"rcs"|"RCS")
		${CO} -f "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}' | ${SED} 's@//@/@' | ${SED} 's@/@@')
		cvs -d "$_CVSROOT" co "$_PATHSPLIT"
		;;
	*)
		${ECHO} "$_CVS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
#checkout the initial revision of the file, used in the 3-way merge
CHECKOUT-FIRST)
	case $_VCS in
	"rcs"|"RCS")
		${CO} -f1.1 "$CFILE"
		exitcode=$?
		;;
	"cvs"|"CVS")
		cd "$_VCSDIR"
		_PATHSPLIT=$(${ECHO} "$CFILE" | ${AWK} -F "$_VCSDIR" '{print $2}' | ${SED} 's@//@/@' | ${SED} 's@/@@')
		cvs -d "$_CVSROOT" co -r1.1 "$_PATHSPLIT"
		;;
	*)
		${ECHO} "$_CVS: unsupported versioning system"
		exitcode=2
		;;
	esac
	;;
MERGE)
	${MERGE} "$FIRSTFILE.automerge" "$FIRSTFILE" "$CFILE"
	exitcode=$?
	;;
PULL)
	${ECHO} "not yet implemented, to be called from +install"
	;;
*)
	${ECHO} "Usage: ./+VERSIONING REGISTER|CHECKOUT|CHECKOUT-FIRST [examplefile]"
	${ECHO} "Usage: ./+VERSIONING MERGE [examplefile] [firstrevision]"
	${ECHO} "Usage: ./+VERSIONING COMMIT [message]"
	${ECHO} "Usage: ./+VERSIONING PREPARE"
	exitcode=3
	;;
esac
exit $exitcode

EOF
	${SED} -n "/^\# VERSIONING: /p" ${SELF} >> ./+VERSIONING
	${CHMOD} +x ./+VERSIONING
	;;
esac
